<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRIPLE PLAY SWITCHUP POKER</title>
    <style>
        /* --- General Styling and Layout (DESKTOP ONLY) --- */
        body {
            font-family: Arial, sans-serif;
            background-color: #000050; 
            color: #FFF;
            text-align: center;
            padding: 0;
            margin: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow: hidden; 
        }

        #main-container {
            display: block;
            max-width: 1400px;
            margin: 0 auto;
            width: 98%;
            padding: 0;
        }

        /* --- Game Container: Single Unified Area --- */
        #game-container {
            background-color: #000080; 
            border-radius: 15px;
            border: 4px solid #FFD700; 
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            padding: 10px;
            width: 100%;
            height: 98vh;
            max-width: 1200px;
            position: relative; 
            display: flex; 
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
        }

        /* --- Title Styling (Top Center) --- */
        #game-container h1 {
            font-family: 'Georgia', serif;
            font-size: 2.0em; 
            font-weight: 900;
            letter-spacing: 3px;
            margin-top: 5px; 
            margin-bottom: 5px; 
            text-transform: uppercase;
            color: #FFD700;
            text-shadow:
                -3px -3px 0 #8B0000,
                 3px -3px 0 #8B0000,
                -3px 3px 0 #8B0000,
                 3px 3px 0 #8B0000,
                 0 0 10px rgba(255, 255, 255, 0.7);
        }

        /* âš¡ï¸ Global Controls (Absolute Position) âš¡ï¸ */
        #global-controls {
            position: absolute;
            bottom: 10px; 
            right: 10px; 
            z-index: 100;
            display: flex;
            gap: 10px;
            align-items: center; 
        }

        .control-icon {
            background-color: #CC0000;
            color: #FFD700;
            border: 2px solid #FFD700;
            border-radius: 8px; 
            min-width: 40px; 
            height: 40px;
            font-size: 0.9em; 
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 0 2px rgba(0,0,0,0.5);
            transition: background-color 0.2s;
            padding: 0 10px;
            line-height: 40px; 
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: left; 
            display: flex;
            align-items: center;
            justify-content: flex-start; 
            white-space: nowrap; 
        }

        #sound-toggle, #help-button {
             width: 40px;
             min-width: 40px;
             border-radius: 50%;
             font-size: 1.5em;
             padding: 0;
             line-height: 36px;
             justify-content: center; 
             text-align: center;
        }

        .control-icon:hover {
            background-color: #8B0000;
        }

        #auto-hold-toggle {
            width: 150px; 
        }
        
        #auto-hold-toggle.on {
            background-color: #00CC00; 
            color: #000050; 
            border-color: #008000;
        }

        #auto-hold-toggle.off {
            background-color: #800000; 
            color: #FFD700; 
            border-color: #500000;
        }
        
        #text-toggle {
            position: absolute;
            bottom: 10px; 
            left: 10px; 
            z-index: 100;
            width: 130px;
            border-radius: 8px; 
            min-width: 40px; 
            height: 40px;
            font-size: 0.9em; 
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 0 2px rgba(0,0,0,0.5);
            transition: background-color 0.2s;
            padding: 0 10px;
            line-height: 40px; 
            text-transform: uppercase;
            text-align: center;
        }
        #text-toggle.off {
            background-color: #008000; 
            color: #FFF; 
            border-color: #00FF00;
        }
        #text-toggle.on {
            background-color: #8B0000; 
            color: #FFD700;
            border-color: #CC0000;
        }
        
        #message-area.hidden {
            visibility: hidden;
            height: 0;
            padding: 0;
            margin-bottom: 0;
        }

        
        /* --- Stats Bar (Below Title) --- */
        #stats-bar-local {
            display: flex;
            justify-content: space-around;
            width: 70%;
            max-width: 800px;
            margin-bottom: 5px; 
            padding: 10px 0; 
            background-color: #CC0000;
            border-radius: 5px;
            border: 2px solid #FFD700;
            color: #FFD700;
            font-family: 'Courier New', monospace;
        }

        .stat-box {
            font-size: 1.2em;
            font-weight: bold;
            flex: 1;
            text-align: center;
        }

        #credits-stat, #bet-stat, #winnings-stat {
            color: #FFFFFF;
            text-shadow: 0 0 3px #000;
            font-size: 1.4em;
            display: inline-block;
        }

        /* âš¡ï¸ TRIPLE PLAY: Card Display Area âš¡ï¸ */
        #card-area-wrapper {
             width: 80%;
             max-width: 900px; 
             position: relative; 
             margin: 0 auto;
             min-height: 550px; 
             display: flex;
             flex-direction: column;
             align-items: center;
             justify-content: flex-start;
             padding-top: 5px;
             flex-grow: 1; 
        }
        
        /* 3 ×©×•×¨×•×ª ×”×§×œ×¤×™× */
        .multi-hand-row {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            margin-bottom: 5px; 
        }
        
        .hand-label {
             display: none;
        }

        #card-area, #hand-1 .hand-cards-container, #hand-2 .hand-cards-container { 
            display: flex;
            justify-content: center;
            gap: 10px; 
            width: 100%;
            min-height: 160px; 
        }

        .card-slot {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px; 
        }

        /* âš¡ï¸ WIN OVERLAY STYLE (×‘×¡×™×¡) âš¡ï¸ */
        .win-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90px;
            height: 55px;
            border: 2px solid #FFD700;
            border-radius: 5px;
            color: #FFF; 
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 0.9em;
            font-weight: bold;
            line-height: 1.2;
            text-align: center;
            padding: 2px;
            z-index: 20; 
            pointer-events: none;
        }
        /* ×¦×‘×¢×™× ×¡×¤×¦×™×¤×™×™× ×œ×¡×•×’×™ ×–×›×™×™×” */
        .win-overlay.win-JacksOrBetter, .win-overlay.win-PairBelowJacks { background-color: #FF4500; } 
        .win-overlay.win-TwoPair { background-color: #FF0000; } 
        .win-overlay.win-ThreeOfAKind { background-color: #00008B; } 
        .win-overlay.win-Straight { background-color: #DAA520; } 
        .win-overlay.win-Flush { background-color: #006400; } 
        .win-overlay.win-FullHouse,
        .win-overlay.win-FourOfAKind,
        .win-overlay.win-StraightFlush,
        .win-overlay.win-RoyalFlush { background-color: #8B008B; } 


        .win-overlay .win-amount {
            font-size: 1.1em;
            color: #FFFF00;
        }

        .hold-indicator {
            position: absolute;
            top: -20px; 
            z-index: 10;
            font-size: 0.9em;
            font-weight: bold;
            color: #FFFF00;
            background-color: #CC0000;
            padding: 1px 6px;
            border-radius: 4px;
            border: 1px solid #FFD700;
            visibility: hidden;
            pointer-events: none;
            transition: visibility 0.1s;
        }

        .hold-indicator.held {
             visibility: visible;
             background-color: #00CC00;
             color: #000050;
             border-color: #008000;
        }

        /* âš¡ï¸ ×¢×™×¦×•×‘ ×”×§×œ×£ ×œ×ª××•× ×” âš¡ï¸ */
        .card-image {
            width: 110px; 
            height: 155px; 
            background-color: #fff;
            border: 3px solid #000; 
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.4);
            cursor: pointer;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0; 
            background-size: cover !important;
            transition: border 0.2s, box-shadow 0.2s, opacity 0.2s;
        }

        .card-image.joker-glow {
            border: 4px solid #00FF00; 
            box-shadow: 0 0 15px #00FF00, 0 0 5px #00FF00 inset;
            animation: pulse-glow 1s infinite alternate;
        }
        
        @keyframes pulse-glow {
          from { box-shadow: 0 0 15px #00FF00, 0 0 5px #00FF00 inset; }
          to { box-shadow: 0 0 25px #FFFF00, 0 0 8px #FFFF00 inset; }
        }

        .card-image.modified {
            border: 4px solid #FF00FF; 
            box-shadow: 0 0 15px #FF00FF; 
        }

        .card-image.winning-glow {
            border: 3px solid #000; 
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.4);
        }

        .card-image.selected-for-action {
             border: 4px dashed #FFFF00;
             cursor: crosshair;
        }
        
        .card-image.joker-not-selectable {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .card-image.face-down {
             background-image: url('cards/back.png') !important; 
             background-size: cover !important;
             cursor: default;
             border: 3px solid #AAAAAA;
        }

        /* âš¡ï¸ Joker Cards - Absolute Position (×”×¨×•×—×‘ ×”×•×’×“×œ ×œ-200px) âš¡ï¸ */
        #action-cards-container {
            position: absolute;
            top: 25%; 
            left: 5px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            gap: 5px; 
            padding: 0;
            width: 200px; /* ×¨×•×—×‘ ××•×ª×× */
            z-index: 10;
        }
        
        /* âš¡ï¸ ×¢×™×¦×•×‘ ×›×¤×ª×•×¨×™ ×”×’'×•×§×¨ - ×’×•×“×œ 125% âš¡ï¸ */
        .action-card-image {
            width: 137px; 
            height: 68px; 
            border: 2px solid #FFFFFF; 
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.0em; 
            font-weight: bold;
            text-align: center;
            line-height: 1.2;
            color: #FFFFFF; 
            padding: 5px;
            box-sizing: border-box;
            text-transform: uppercase;
            transition: all 0.2s ease-in-out; 
            box-shadow: 0 4px 0 rgba(0,0,0,0.5); /* 3D effect base */
            transform: translateY(0);
            cursor: pointer;
            position: relative; /* ×—×™×•× ×™ ×œ××¤×§×˜ ×”-scale */
            z-index: 1; 
        }
        
        /* ×¦×‘×¢×™ ×¨×§×¢ ×™×™×—×•×“×™×™× ×œ×’'×•×§×¨×™× (×¢× Gradient 3D) */
        #action-cards-container .action-card-slot:nth-child(1) .action-card-image { 
            /* BOOSTER JOKER - ××“×•×-×›×ª×•× */
            background: linear-gradient(to bottom, #FF4500 0%, #CC0000 100%) !important;
        } 
        #action-cards-container .action-card-slot:nth-child(2) .action-card-image { 
            /* FLUSH JOKER - ×™×¨×•×§ */
            background: linear-gradient(to bottom, #00CC00 0%, #006400 100%) !important;
        } 
        #action-cards-container .action-card-slot:nth-child(3) .action-card-image { 
            /* MIRROR JOKER - ×ª×›×œ×ª */
            background: linear-gradient(to bottom, #87CEFA 0%, #40E0D0 100%) !important;
            color: #000050 !important; 
        } 


        /* âš¡ï¸ ××¦×‘ ××•×¦×¢/× ×‘×—×¨ ×™×“× ×™×ª - ××¤×§×˜ ×”-Scale (×’×“×™×œ×”) ×•×¦×‘×¢ ×™×¨×•×§ ×–×•×”×¨ âš¡ï¸ */
        .action-card-slot.pending .action-card-image {
             /* ×“×•×—×£ ×§×“×™××” ×•×’×“×œ */
             transform: scale(1.2) translateY(-2px); 
             z-index: 10;
             
             /* ×¦×‘×¢ ×™×¨×•×§ ×œ×™×™× ×–×•×”×¨ */
             background: linear-gradient(to bottom, #BFFF00 0%, #00FF00 100%) !important;
             color: #000050 !important;
             
             /* ××¡×’×¨×ª ×©×—×•×¨×” ×—×“×” */
             border-color: #000000;
             box-shadow: 0 0 15px #FFFF00; /* ×§×¨×™× ×” ×¦×”×•×‘×” ×—×–×§×” */
             opacity: 1;
        }
        
        /* âš¡ï¸ ××¦×‘ ×œ××—×¨ ×©×™××•×© âš¡ï¸ */
        .action-card-slot.used .action-card-image {
             border-color: #00CC00;
             box-shadow: 0 0 10px #00CC00;
             opacity: 0.6; 
             transform: translateY(0);
        }
        
        /* âš¡ï¸ ××¦×‘ ×œ× ××•×¦×¢/×œ× × ×‘×—×¨ - ×¢××¢×•× âš¡ï¸ */
        .action-cards-container.dim-non-active .action-card-slot .action-card-image:not(.pending):not(.used) {
             opacity: 0.3; 
             box-shadow: 0 4px 0 rgba(0,0,0,0.5); /* ×©××™×¨×ª ×¦×œ ×”-3D */
             transform: translateY(0);
        }
        
        /* âš¡ï¸ ××¦×‘ ×œ×—×™×¦×” ×›×œ×œ×™ (×›×“×™ ×œ×“××•×ª ×œ×—×™×¦×” ×’× ×¢×œ ×›×¤×ª×•×¨ ×¨×’×™×œ) âš¡ï¸ */
        .action-card-button:not(:disabled):active .action-card-image:not(.pending) {
            box-shadow: 0 1px 0 rgba(0,0,0,0.5);
            transform: translateY(3px);
            transition: box-shadow 0.1s, transform 0.1s;
        }


        /* --- Status / Message Area --- */
        #status-area-bottom {
            width: 100%;
            max-width: 750px;
            margin-bottom: 5px;
            padding: 5px 0;
            height: 40px; 
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #message-area {
            font-size: 1.5em; 
            color: #FFFF00; 
            font-weight: bold;
            min-height: 25px;
            margin-bottom: 0px; 
        }

        #hand-status-display {
             display: none; 
        }
        
        /* âš¡ï¸ Control Buttons âš¡ï¸ */
        #control-buttons {
            width: 100%;
            display: flex;
            justify-content: center;
            position: relative; 
            margin-top: 10px;
            margin-bottom: 60px;
        }

        #action-button {
            padding: 15px 80px; 
            font-size: 1.5em; 
            border: 4px solid #FFD700;
            background-color: #CC0000;
            color: #FFD700;
            font-weight: bold;
            box-shadow: 0 5px 0 #8B0000;
            border-radius: 10px;
            cursor: pointer;
        }
    </style>
</head>
<body onclick="game.handleGlobalClick(event)"> 
    <audio id="sound-deal-draw" src="SOUNDS/dealing-card.wav" preload="auto"></audio>
    <audio id="sound-hold" src="SOUNDS/Button Click.mp3" preload="auto"></audio>
    <audio id="sound-win" src="SOUNDS/correct-choice.wav" preload="auto"></audio>
    <audio id="sound-action-card" src="SOUNDS/HELD.mp3" preload="auto"></audio>
    
    <div id="help-modal" style="display: none;"> 
        <div>
            <button class="close-button" onclick="document.getElementById('help-modal').style.display = 'none';">X</button>
            <h2>TRIPLE PLAY SWITCHUP POKER - HOW TO PLAY</h2>

            <p>Your objective is to form the strongest possible 5-card poker hand in 3 separate hands.</p>
            
            <h4>GAMEPLAY FLOW (BASE HAND - HAND 3)</h4>
            <p>1. Click **DEAL** to get your first 5 cards in Hand 3.</p>
            <p>2. **Joker Phase (Hand 3 ONLY):** You can use one Joker (Upgrade, Flush, Mirror) to modify a card. The optimal move will **Glow Green**.</p>
            <ul>
                <li>**Action (Joker/Hold):** Tap the glowing card to apply the hint, or click a Joker button on the left for manual selection. Tap any non-glowing card to **HOLD** it. **The held cards will appear instantly in the upper hands.**</li>
            </ul>
            <p>3. **DRAW:** Once the Joker is used (××• ×‘×•×˜×œ) ×•×”-HOLDs × ×‘×—×¨×•:</p>
            <ul>
                <li>The held/modified cards from Hand 3 are **copied** to Hand 1 and Hand 2.</li>
                <li>All 3 hands draw replacement cards from 3 separate decks.</li>
            </ul>
            <p>4. Your three final hands are evaluated for total payout.</p>
            

            <button onclick="document.getElementById('help-modal').style.display = 'none';" style="margin-top: 20px;">Close</button>
        </div>
    </div>

    <div id="main-container">

        <div id="game-container">

            <h1>TRIPLE PLAY SWITCHUP POKER</h1>
            
            <div id="global-controls">
                <button id="cancel-hint-button" class="control-icon" title="Cancel Upgrade Hint" onclick="game.cancelJokerHint()">
                    CANCEL HINT
                </button>
                <button id="auto-hold-toggle" class="control-icon" title="Toggle Auto Hold">AUTO HOLD</button>
                <button id="sound-toggle" class="control-icon" title="Toggle Sound">ğŸ”Š</button>
                <button id="help-button" class="control-icon" title="Game Help" onclick="openHelpFile()">?</button>
            </div>
            
            <button id="text-toggle" class="control-icon on" title="Toggle Text Messages" onclick="game.toggleTextDisplay()">HIDE TEXT</button>


            <div id="stats-bar-local">
                <div class="stat-box">Credits: <span id="credits-stat">500</span></div>
                <div class="stat-box">Total Bet: <span id="bet-stat">30</span></div>
                <div class="stat-box">Last Win: <span id="winnings-stat">0</span></div>
            </div>

            <div id="action-cards-container">
                </div> 

            <div id="card-area-wrapper">
                
                <div id="hand-1" class="multi-hand-row">
                    <div class="hand-cards-container"></div>
                </div>
                
                <div id="hand-2" class="multi-hand-row">
                    <div class="hand-cards-container"></div>
                </div>
                
                <div id="hand-3" class="multi-hand-row">
                    <div id="card-area" class="hand-cards-container">
                    </div>
                </div>

                <div id="status-area-bottom">
                    <div id="message-area">Click DEAL. Total Cost: 30.</div>
                </div>

                <div id="hand-status-display">
                    <span id="hand-status"></span>
                </div>

            </div>
            
            <div id="control-buttons">
                <button id="action-button" onclick="game.handleActionButton()">DEAL</button>
            </div>

            </div>

    </div>

<script>
    // --- SOUND HELPER FUNCTION ---
    function playSound(elementId) {
        const audio = document.getElementById(elementId);
        if (audio && isSoundOn) { 
            audio.currentTime = 0;
            audio.play().catch(e => console.log("Audio play failed:", e));
        }
    }

    // --- Global Sound and Help Functions ---
    let isSoundOn = true;

    function toggleSound() {
        isSoundOn = !isSoundOn;
        const soundButton = document.getElementById('sound-toggle');
        soundButton.textContent = isSoundOn ? 'ğŸ”Š' : 'ğŸ”‡';

        const allAudio = document.querySelectorAll('audio');
        allAudio.forEach(audio => {
            audio.muted = !isSoundOn;
        });
    }

    function openHelpFile() {
        document.getElementById('help-modal').style.display = 'flex';
    }
    // ----------------------------------------

    // --- 1. Game Constants & Setup ---
    const SUITS = ["clubs", "diamonds", "hearts", "spades"];
    const RANKS = Array.from({length: 13}, (_, i) => i + 2);
    const STARTING_CREDITS = 500;
    const INITIAL_BET = 10; 
    const MOD_CARD_COST = 0; 
    const NUM_HANDS = 3;
    const CARD_IMAGE_PATH = 'cards/'; 
    const ACTION_CARD_IMAGE_PATH = 'Action_Cards/'; 
    const COUNT_DURATION = 1000;
    const MODIFICATION_TIMEOUT = 2000;
    const GLOW_DELAY = 1000;
    
    // âš¡ï¸ ××›×¤×œ×” ××¢×•×“×›× ×ª ×œ-1 âš¡ï¸
    const PAYTABLE_MULTIPLIER = 1; 
    
    const PAYTABLE = {
        "Royal Flush": 4000 * PAYTABLE_MULTIPLIER, "Straight Flush": 250 * PAYTABLE_MULTIPLIER, "Four of a Kind": 125 * PAYTABLE_MULTIPLIER,
        "Full House": 45 * PAYTABLE_MULTIPLIER, "Flush": 30 * PAYTABLE_MULTIPLIER, "Straight": 20 * PAYTABLE_MULTIPLIER,
        "Three of a Kind": 15 * PAYTABLE_MULTIPLIER, "Two Pair": 10 * PAYTABLE_MULTIPLIER, "Jacks or Better": 5 * PAYTABLE_MULTIPLIER,
        "Pair (Below Jacks)": 0, "High Card": 0, "Invalid Hand": 0
    };
    
    const HAND_RANKING = {
        "Royal Flush": 10, "Straight Flush": 9, "Four of a Kind": 8, "Full House": 7, "Flush": 6, "Straight": 5,
        "Three of a Kind": 4, "Two Pair": 3, "Jacks or Better": 2, "Pair (Below Jacks)": 1, "High Card": 0, "Invalid Hand": -1
    };

    const ACTION_CARD_DEFINITIONS = [
        { name: "upgrade", display: "BOOSTER JOKER", filename: "booster_final.png" },
        { name: "flush_fever", display: "FLUSH JOKER", filename: "FEVER.png" },
        { name: "mirror_hand", display: "MIRROR JOKER", filename: "1.png" },
    ];
    
    const JOKER_ACTIONS = [
        { name: "upgrade" }, { name: "flush_fever" }, { name: "mirror_hand" },
    ];


    function cardExists(hand, cardToCheck, indexToIgnore) {
        return hand.some((card, index) =>
            index !== indexToIgnore && card && card.isEqual(cardToCheck)
        );
    }

    // --- 2. Card Classes ---
    class Card {
        constructor(suit, rank) {
            this.suit = suit;
            this.rank = rank;
            this.rankStr = this.getRankStr();
        }

        getRankStr() {
            const ranksMap = { 11: 'J', 12: 'Q', 13: 'K', 14: 'A' };
            return ranksMap[this.rank] || String(this.rank);
        }

        getSuitSymbol() {
            const symbols = { 'clubs': 'â™£', 'diamonds': 'â™¦', 'hearts': 'â™¥', 'spades': 'â™ ' };
            return symbols[this.suit];
        }

        toString() {
            return `${this.rankStr}${this.getSuitSymbol()}`;
        }

        isEqual(otherCard) {
            return otherCard && this.suit === otherCard.suit && this.rank === otherCard.rank;
        }

        getImagePath() {
            return `${CARD_IMAGE_PATH}${this.rankStr}_of_${this.suit}.png`;
        }

        getColorClass() {
            return (this.suit === 'hearts' || this.suit === 'diamonds') ? 'red-suit' : '';
        }
    }

    class Deck {
        constructor() {
            this.cards = [];
            this.reset();
        }

        reset() {
            this.cards = [];
            for (const suit of SUITS) {
                for (const rank of RANKS) {
                    this.cards.push(new Card(suit, rank));
                }
            }
            this.shuffle();
        }

        shuffle() {
            for (let i = this.cards.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]];
            }
        }

        dealCard() {
            if (this.cards.length > 0) {
                return this.cards.splice(this.cards.length - 1, 1)[0]; 
            }
            return null;
        }
    }

    // --- 3. Evaluation Logic (No Change) ---
    function evaluateHand(hand) {
        if (!hand || hand.length !== 5 || hand.some(c => !c)) return "Invalid Hand";

        const ranks = hand.map(card => card.rank).sort((a, b) => a - b);
        const suits = hand.map(card => card.suit);
        const rankCounts = ranks.reduce((counts, rank) => {
            counts.set(rank, (counts.get(rank) || 0) + 1);
            return counts;
        }, new Map());

        const isFlush = new Set(suits).size === 1;
        const isSequential = ranks[4] - ranks[0] === 4 && new Set(ranks).size === 5;
        const isAceLow = ranks.toString() === '2,3,4,5,14';
        const isStraight = isSequential || isAceLow;

        let pairs = 0;
        let threes = 0;
        let fours = 0;

        for (const count of rankCounts.values()) {
            if (count === 4) fours++;
            else if (count === 3) threes++;
            else if (count === 2) pairs++;
        }

        if (isStraight && isFlush) {
            if (ranks.toString() === '10,11,12,13,14') return "Royal Flush";
            return "Straight Flush";
        }
        if (fours === 1) return "Four of a Kind";
        if (threes === 1 && pairs === 1) return "Full House";
        if (isFlush) return "Flush";
        if (isStraight) return "Straight";
        if (threes === 1) return "Three of a Kind";
        if (pairs === 2) return "Two Pair";

        if (pairs === 1) {
            for (const [rank, count] of rankCounts.entries()) {
                if (count === 2 && rank >= 11) return "Jacks or Better";
            }
            return "Pair (Below Jacks)";
        }
        return "High Card";
    }

    // âš¡ï¸ Joker/Hint Logic âš¡ï¸
    function isCardValidForAction(card, hand, index, actionType) {
        if (!card) return false;

        if (actionType === "upgrade") {
            const newRank = card.rank + 1;
            if (newRank > 14) return false;
            
            const simulatedCard = new Card(card.suit, newRank);
            if (cardExists(hand, simulatedCard, index)) return false;

            return true;
        } else if (actionType === "flush_fever") {
            const suitCounts = hand.reduce((counts, c) => {
                if (c) counts.set(c.suit, (counts.get(c.suit) || 0) + 1);
                return counts;
            }, new Map());

            let mostCommonSuit = null;
            let maxCount = 0;
            for (const [suit, count] of suitCounts.entries()) {
                if (count > maxCount) { maxCount = count; mostCommonSuit = suit; }
            }
            
            if (mostCommonSuit && card.suit !== mostCommonSuit) {
                 const simulatedCard = new Card(mostCommonSuit, card.rank);
                 if (cardExists(hand, simulatedCard, index)) return false;
                 return true;
            }
            return false;
        } 
        return true; 
    }
    
    function cloneHand(hand) {
        return hand.map(card => new Card(card.suit, card.rank));
    }

    // âš¡ï¸ Helper to map hand name to CSS class for unique colors âš¡ï¸
    function getWinClass(handName) {
        if (handName.includes('Jacks or Better') || handName.includes('Pair (Below Jacks)')) return 'win-JacksOrBetter';
        if (handName.includes('Two Pair')) return 'win-TwoPair';
        if (handName.includes('Three of a Kind')) return 'win-ThreeOfAKind';
        if (handName.includes('Straight Flush')) return 'win-StraightFlush';
        if (handName.includes('Royal Flush')) return 'win-RoyalFlush';
        if (handName.includes('Four of a Kind')) return 'win-FourOfAKind';
        if (handName.includes('Full House')) return 'win-FullHouse';
        if (handName.includes('Flush')) return 'win-Flush';
        if (handName.includes('Straight')) return 'win-Straight';
        return '';
    }


    // --- 4. Game Class (Full Logic) ---
    class PokerGame {
        constructor() {
            this.deck = new Deck(); 
            this.drawDecks = []; 
            this.playerHands = [[], [], []]; 
            this.heldCards = [false, false, false, false, false]; 

            this.actionCardUsedThisRound = false;
            this.credits = STARTING_CREDITS;
            this.bet = INITIAL_BET; 
            this.totalBet = (this.bet * NUM_HANDS); // 30 ×§×¨×“×™×˜×™×
            this.modCardCost = MOD_CARD_COST; 

            this.lastWinnings = 0;
            this.winningHandNames = []; // [{handIndex: i, name: name, winnings: winnings}]

            this.gameState = "DEAL"; 
            this.bestJokerAction = null; 
            this.jokerUsedType = null; 
            this.activeManualJoker = null;
            this.isGlowActive = false; 
            
            this.isAutoHoldOn = false; 
            this.isTextHidden = false; 

            this.message = `Click DEAL. Total Cost: ${this.totalBet}.`;
            
            for (let i = 0; i < NUM_HANDS; i++) {
                 this.playerHands[i] = Array(5).fill(null); 
            }

            this.updateUI();
        }

        setMessage(newMessage, isCritical = false) {
             if (this.isTextHidden && !isCritical) {
                 this.message = '';
             } else {
                 this.message = newMessage;
             }
        }
        
        toggleTextDisplay() {
            this.isTextHidden = !this.isTextHidden;
            const messageAreaEl = document.getElementById('message-area');
            const textToggleEl = document.getElementById('text-toggle');

            if (this.isTextHidden) {
                messageAreaEl.classList.add('hidden');
                textToggleEl.classList.remove('on');
                textToggleEl.classList.add('off');
                textToggleEl.textContent = 'SHOW TEXT';
                this.setMessage('');
            } else {
                messageAreaEl.classList.remove('hidden');
                textToggleEl.classList.remove('off');
                textToggleEl.classList.add('on');
                textToggleEl.textContent = 'HIDE TEXT';
                
                if (this.gameState === "DEAL" || this.gameState === "END_ROUND") {
                     this.setMessage(`Click NEW HAND. Total Cost: ${this.totalBet}.`);
                } else if (this.gameState === "ACTION_PHASE") {
                     if (this.activeManualJoker) {
                         this.setMessage(`Tap Card to Apply, or Tap ICON to Cancel.`);
                     } else if (this.bestJokerAction && this.bestJokerAction.type && this.isGlowActive) {
                         this.setMessage(`Tap Glowing Card to UPGRADE or HOLD.`);
                     } else {
                         this.setMessage(`Your Hand.`);
                     }
                }
            }
            this.updateUI();
        }

        // âš¡ï¸ ×©×›×¤×•×œ ×§×œ×¤×™× ××•×—×–×§×™× ×œ×™×“×™×™× ×”×¢×œ×™×•× ×•×ª (×•×™×–×•××œ×™ ×•× ×ª×•× ×™) âš¡ï¸
        replicateHolds() {
             const baseHand = this.playerHands[2];
             
             // ×©×›×¤×œ ×œ-Hand 0 ×•-Hand 1
             for (let i = 0; i < NUM_HANDS - 1; i++) {
                 const currentHand = this.playerHands[i];
                 for (let j = 0; j < 5; j++) {
                     if (this.heldCards[j]) {
                         // **×”×¢×ª×§×ª ×”×§×œ×£ ×”××•×—×–×§ (Clone) ×œ×™×“×™×™× ×”×¢×œ×™×•× ×•×ª**
                         currentHand[j] = new Card(baseHand[j].suit, baseHand[j].rank); 
                     } else {
                         // ×•×“× ×©×”×§×œ×£ ×œ× ××•×—×–×§ (× ×©××¨ null/×’×‘ ×§×œ×£)
                         currentHand[j] = null;
                     }
                 }
             }
        }


        handleActionButton() {
             if (this.gameState === "DEAL" || this.gameState === "END_ROUND") {
                 this.dealHand();
             } else if (this.gameState === "ACTION_PHASE") {
                 if (this.activeManualJoker && this.activeManualJoker !== 'mirror_hand') {
                      this.setMessage(`Tap Card to Apply, or Tap ICON to Cancel.`, true);
                      this.updateUI();
                      return;
                 }
                 this.drawCards();
             }
        }

        dealHand() {
            if (this.gameState !== "DEAL" && this.gameState !== "END_ROUND") return;

            if (this.credits < this.totalBet) {
                this.setMessage(`Not Enough Credits: ${this.totalBet}`, true);
                this.updateUI();
                return;
            }

            this.credits -= this.totalBet;
            
            // 1. × ×§×” ××¦×‘
            this.deck.reset();
            this.playerHands = [[], [], []]; 
            this.heldCards = [false, false, false, false, false]; 
            this.winningHandNames = [];

            // 2. ×“×™×œ ×œ×™×“ ×”×‘×¡×™×¡ (Hand 2)
            this.playerHands[2] = this.deck.cards.splice(0, 5); 
            
            // 3. ××›×œ×•×¡ 2 ×”×™×“×™×™× ×”×¢×œ×™×•× ×•×ª ×‘×’×‘ ×§×œ×£
            for (let i = 0; i < NUM_HANDS - 1; i++) {
                 this.playerHands[i] = Array(5).fill(null); 
            }

            // 4. ×”×›×Ÿ 3 ×—×¤×™×¡×•×ª × ×¤×¨×“×•×ª ×œ×©×œ×‘ ×”-Draw
            this.drawDecks = [];
            const dealtCards = this.playerHands[2];
            for (let i = 0; i < NUM_HANDS; i++) {
                 const newDeck = new Deck();
                 newDeck.cards = newDeck.cards.filter(deckCard => 
                    !dealtCards.some(dealtCard => dealtCards.length > 0 && dealtCard.isEqual(deckCard))
                 );
                 newDeck.shuffle();
                 this.drawDecks.push(newDeck);
            }

            this.actionCardUsedThisRound = false;
            this.jokerUsedType = null;
            this.activeManualJoker = null;
            this.bestJokerAction = this.findBestJokerAction();
            this.isGlowActive = false;
            
            this.gameState = "ACTION_PHASE";
            this.setMessage("Your Hand.");
            
            if (this.isAutoHoldOn && !this.bestJokerAction.type) {
                 this.autoHoldBestCards();
            }

            this.replicateHolds(); // ×©×›×¤×•×œ ×¨××©×•× ×™ ×©×œ Hand 3 ×”×¨×™×§×” ×œ-Hand 0/1 (×’×‘ ×§×œ×£)
            this.updateUI();
            playSound('sound-deal-draw');
            
            if (this.bestJokerAction.type) {
                setTimeout(() => {
                    this.isGlowActive = true;
                    this.setMessage("Tap Glowing Card to UPGRADE or HOLD.");
                    this.updateUI();
                }, GLOW_DELAY);
            }
        }

        drawCards() {
            if (this.gameState !== "ACTION_PHASE") return;
            
            let totalWinnings = 0;
            this.winningHandNames = [];
            
            // 1. ×©×›×¤×œ ××ª ×”×§×œ×¤×™× ×”××•×—×–×§×™× ×œ×™×“×™×™× Hand 0 ×•-Hand 1 (× ×“×¨×© ×©×•×‘ ×›×™ ×”×’'×•×§×¨ ×™×›×•×œ ×œ×©× ×•×ª ××ª Hand 2)
            this.replicateHolds();
            
            // 2. ×‘×¦×¢ Draw ×•×”×¢×¨×š ×¢×‘×•×¨ ×›×œ ×™×“
            for (let i = 0; i < NUM_HANDS; i++) {
                const hand = this.playerHands[i];
                const deck = this.drawDecks[i]; 
                
                // ×‘×¦×¢ Draw
                for (let j = 0; j < 5; j++) {
                    if (!this.heldCards[j]) { 
                        let newCard = null;
                        let attempts = 0;
                         do {
                            deck.shuffle(); 
                            newCard = deck.dealCard(); 
                            attempts++;
                         } while (newCard && cardExists(hand, newCard, j) && attempts < 52); 

                        if (newCard) {
                             hand[j] = newCard;
                        }
                    }
                }
                
                // 3. ×”×¢×¨×š ×•×—×©×‘ ×–×›×™×™×”
                const handName = evaluateHand(hand);
                const handWinnings = PAYTABLE[handName] || 0;
                
                totalWinnings += handWinnings;
                if (handWinnings > 0) {
                    this.winningHandNames.push({ handIndex: i, name: handName, winnings: handWinnings });
                }
            }
            
            this.bestJokerAction = null;
            this.isGlowActive = false;
            this.activeManualJoker = null;

            this.lastWinnings = totalWinnings;
            this.gameState = "END_ROUND";
            this.evaluateFinalHand();
            this.updateUI();

            playSound('sound-deal-draw');
        }
        
        animateCreditCount(amount) {
            if (amount === 0) { this.updateUI(); return; }
            const startCredits = this.credits;
            const endCredits = this.credits + amount;
            const startTime = performance.now();
            const creditsStatEl = document.getElementById('credits-stat');
            creditsStatEl.style.color = '#00CC00';
            creditsStatEl.style.fontSize = '1.3em';
            const step = (timestamp) => {
                const elapsed = timestamp - startTime;
                const progress = Math.min(elapsed / COUNT_DURATION, 1);
                const easedProgress = progress * progress * (3 - 2 * progress);
                const currentValue = Math.floor(startCredits + amount * easedProgress);
                creditsStatEl.textContent = currentValue;
                if (progress < 1) { requestAnimationFrame(step); } else {
                    this.credits = endCredits;
                    creditsStatEl.textContent = endCredits;
                    setTimeout(() => {
                        creditsStatEl.style.color = '#CCFF00';
                        creditsStatEl.style.fontSize = '';
                        this.updateUI();
                    }, 200);
                }
            };
            requestAnimationFrame(step);
        }

        evaluateFinalHand() {
            const totalWinnings = this.lastWinnings;
            
            if (totalWinnings > 0) {
                 const winMessages = this.winningHandNames.map(w => `${w.name} (H${w.handIndex + 1})`).join(', ');
                 this.setMessage(`Total WIN: ${totalWinnings} Credits! (${winMessages})`);
            } else {
                 this.setMessage(`Click NEW HAND.`);
            }

            this.gameState = "END_ROUND";

            document.getElementById('message-area').textContent = this.message;
            document.getElementById('hand-status').textContent = '';

            if (totalWinnings > 0) {
                 playSound('sound-win');
            }

            this.animateCreditCount(totalWinnings);
        }
        
        updateHandStatus(handName) {
            const handStatusEl = document.getElementById('hand-status');
            if (HAND_RANKING[handName] >= HAND_RANKING["Jacks or Better"]) {
                handStatusEl.textContent = `${handName}`;
            } else {
                 handStatusEl.textContent = '';
            }
        }
        
        findBestJokerAction() {
            const hand = this.playerHands[2];
            if (this.actionCardUsedThisRound) return { rank: HAND_RANKING[evaluateHand(hand)], type: null, index: null };

            const currentHandRank = HAND_RANKING[evaluateHand(hand)];
            let bestAction = { rank: currentHandRank, type: null, index: null };
            
            JOKER_ACTIONS.forEach(action => { 
                const actionType = action.name;
                
                if (actionType === 'mirror_hand') {
                    hand.forEach((card, index) => {
                        if (card.rank >= 2 && card.rank <= 4) {
                            const mirrorTestHand = cloneHand(hand);
                            let tempCardModified = false;
                            for (let i = 0; i < 5; i++) {
                                 let originalCard = mirrorTestHand[i];
                                 let newR = originalCard.rank;
                                 if (newR === 2) newR = 14; else if (newR === 3) newR = 13; else if (newR === 4) newR = 12;
                                 if (originalCard.rank !== newR) {
                                     let simCard = new Card(originalCard.suit, newR);
                                     if (!cardExists(mirrorTestHand, simCard, i)) {
                                         originalCard.rank = newR;
                                         originalCard.rankStr = originalCard.getRankStr();
                                         tempCardModified = true;
                                     }
                                 }
                            }
                            if (tempCardModified) {
                                const mirrorRank = HAND_RANKING[evaluateHand(mirrorTestHand)];
                                if (mirrorRank > bestAction.rank) { bestAction = { rank: mirrorRank, type: 'mirror_hand', index: index }; }
                            }
                        }
                    });
                } 
                
                else if (actionType === 'upgrade' || actionType === 'flush_fever') {
                    hand.forEach((card, index) => {
                        if (isCardValidForAction(card, hand, index, actionType)) {
                            const testHand = cloneHand(hand);
                            let testCard = testHand[index];
                            let modifiedCard = null;
                            if (actionType === 'upgrade') {
                                 modifiedCard = new Card(testCard.suit, testCard.rank + 1);
                            } else if (actionType === 'flush_fever') {
                                const suitCounts = hand.reduce((counts, c) => {
                                    if (c) counts.set(c.suit, (counts.get(c.suit) || 0) + 1);
                                    return counts;
                                }, new Map());
                                let mostCommonSuit = null;
                                let maxCount = 0;
                                for (const [suit, count] of suitCounts.entries()) {
                                    if (count > maxCount) { maxCount = count; mostCommonSuit = suit; }
                                }
                                modifiedCard = new Card(mostCommonSuit, testCard.rank);
                            }
                            if (modifiedCard) {
                                 testHand[index] = modifiedCard;
                                 const testRank = HAND_RANKING[evaluateHand(testHand)];
                                 if (testRank > bestAction.rank) {
                                    bestAction = { rank: testRank, type: actionType, index: index };
                                 }
                            }
                        }
                    });
                }
            });

            return bestAction;
        }
        
        setManualJokerMode(jokerType) {
            if (this.gameState !== "ACTION_PHASE" || this.actionCardUsedThisRound) return;
            if (this.activeManualJoker === jokerType) { this.cancelManualJokerMode(); return; }
            this.activeManualJoker = jokerType;
            this.isGlowActive = false;
            
            if (jokerType === 'mirror_hand') {
                this.applyJokerEffect(null, jokerType);
                this.actionCardUsedThisRound = true;
                this.jokerUsedType = jokerType;
                this.activeManualJoker = null;
                if (this.isAutoHoldOn) { this.autoHoldBestCards(); }
                this.replicateHolds(); // ×©×›×¤×•×œ ××™×™×“×™
                this.setMessage(`Joker Used. Select HOLDs or DRAW.`); 
            } else {
                 this.setMessage(`Tap Card to Apply, or Tap ICON to Cancel.`);
            }
            this.updateUI();
        }
        
        cancelManualJokerMode() {
            this.activeManualJoker = null;
            if (!this.actionCardUsedThisRound && this.bestJokerAction.type) {
                this.isGlowActive = true;
                this.setMessage("Tap Glowing Card to UPGRADE or HOLD.");
            } else {
                this.setMessage("Select HOLDs or DRAW.");
            }
            this.updateUI();
        }

        cancelJokerHint() {
            if (this.isGlowActive && !this.actionCardUsedThisRound) {
                 this.isGlowActive = false;
                 if (this.isAutoHoldOn) { this.autoHoldBestCards(); }
                 this.setMessage("Select HOLDs or DRAW.");
                 this.replicateHolds(); // ×©×›×¤×•×œ ××™×™×“×™
                 this.updateUI();
            }
        }

        toggleAutoHold() {
            this.isAutoHoldOn = !this.isAutoHoldOn;
            if (this.isAutoHoldOn && this.gameState === "ACTION_PHASE" && !this.actionCardUsedThisRound && !this.isGlowActive) {
                 this.autoHoldBestCards();
                 this.replicateHolds(); // ×©×›×¤×•×œ ××™×™×“×™
            } else if (!this.isAutoHoldOn) {
                 this.heldCards.fill(false);
                 this.replicateHolds(); // ×¢×“×›×•×Ÿ ××™×™×“×™
            }
            this.updateUI();
        }

        handleGlobalClick(event) {
             // Logic to cancel modes if click is outside of controls (if needed, but simpler to omit here)
        }

        activateOneTapJoker(cardIndex) {
            if (this.gameState !== "ACTION_PHASE") return; 
            
            let actionToExecute = null;
            let targetIndex = cardIndex;
            const hand = this.playerHands[2];
            
            if (this.activeManualJoker && this.activeManualJoker !== 'mirror_hand') {
                 actionToExecute = this.activeManualJoker;
                 if (!isCardValidForAction(hand[cardIndex], hand, cardIndex, actionToExecute)) {
                      this.setMessage(`Invalid Target. Choose another card.`, true);
                      this.updateUI();
                      return;
                 }
            } 
            else if (!this.actionCardUsedThisRound && this.isGlowActive && this.bestJokerAction.type) {
                const bestAction = this.bestJokerAction;
                if (bestAction.type === 'mirror_hand') {
                    if (hand[cardIndex].rank >= 2 && hand[cardIndex].rank <= 4) {
                        this.setManualJokerMode(bestAction.type);
                        return;
                    }
                } else if (bestAction.index === cardIndex) {
                    actionToExecute = bestAction.type;
                }
            }

            if (actionToExecute) {
                 this.applyJokerEffect(targetIndex, actionToExecute);
                 this.actionCardUsedThisRound = true;
                 this.jokerUsedType = actionToExecute;
                 this.bestJokerAction = null;
                 this.isGlowActive = false;
                 this.activeManualJoker = null;
                 if (this.isAutoHoldOn) { this.autoHoldBestCards(); }
                 this.setMessage(`Joker Used. Select HOLDs or DRAW.`);
                 
                 // ×©×›×¤×•×œ ××™×™×“×™ ×œ××—×¨ ×©×™××•×© ×‘×’'×•×§×¨
                 this.replicateHolds();
                 this.updateUI();
            } else {
                this.toggleHold(cardIndex);
            }
        }

        applyJokerEffect(cardIndex, actionType) {
            const hand = this.playerHands[2];
            let cardModified = false;
            let cardsToHighlight = [];
            let cardToModify = cardIndex !== null && cardIndex !== undefined ? hand[cardIndex] : null;

            if (actionType === "mirror_hand") {
                for (let i = 0; i < 5; i++) {
                    const cardOriginal = hand[i];
                    let newRank = cardOriginal.rank;

                    if (cardOriginal.rank === 2) newRank = 14;
                    else if (cardOriginal.rank === 3) newRank = 13;
                    else if (cardOriginal.rank === 4) newRank = 12;

                    if (cardOriginal.rank !== newRank) {
                        const tempSimulatedCard = new Card(cardOriginal.suit, newRank);
                        if (!cardExists(hand, tempSimulatedCard, i)) {
                            hand[i].rank = newRank;
                            hand[i].rankStr = hand[i].getRankStr();
                            cardModified = true;
                            cardsToHighlight.push(i);
                        }
                    }
                }
            } else if (actionType === "upgrade" && cardToModify) {
                cardToModify.rank += 1;
                cardToModify.rankStr = cardToModify.getRankStr();
                cardModified = true;
                cardsToHighlight.push(cardIndex);
            } else if (actionType === "flush_fever" && cardToModify) {
                const suitCounts = hand.reduce((counts, card) => {
                    if (card) counts.set(card.suit, (counts.get(card.suit) || 0) + 1);
                    return counts;
                }, new Map());

                let mostCommonSuit = null;
                let maxCount = 0;
                for (const [suit, count] of suitCounts.entries()) {
                    if (count > maxCount) { maxCount = count; mostCommonSuit = suit; }
                }

                if (mostCommonSuit && cardToModify.suit !== mostCommonSuit) {
                    cardToModify.suit = mostCommonSuit;
                    cardModified = true;
                    cardsToHighlight.push(cardIndex);
                }
            }

            if (cardModified) {
                 playSound('sound-action-card');
                 
                 cardsToHighlight.forEach(index => {
                     const cardEl = document.getElementById(`card-${index}`);
                     if (cardEl) {
                         cardEl.classList.add('modified');
                         setTimeout(() => {
                             cardEl.classList.remove('modified');
                         }, MODIFICATION_TIMEOUT);
                     }
                 });
            } 
        }

        toggleHold(cardIndex) {
            if (this.gameState === "ACTION_PHASE") {
                
                if (this.activeManualJoker && this.activeManualJoker !== 'mirror_hand') {
                     this.setMessage(`Tap Card to Apply, or Tap ICON to Cancel.`, true);
                     this.updateUI();
                     return;
                }
                
                this.heldCards[cardIndex] = !this.heldCards[cardIndex];

                this.setMessage(this.actionCardUsedThisRound ? "Joker Used. Select HOLDs or DRAW." : "Tap Glowing Card to UPGRADE or HOLD.");
                
                // **×©×›×¤×•×œ ××™×™×“×™**
                this.replicateHolds();
                this.updateUI();
                playSound('sound-hold');
            }
        }

        // --- UI Rendering Logic ---
        updateUI() {
            // Update Stats Bar (Local)
            document.getElementById('winnings-stat').textContent = this.lastWinnings;
            document.getElementById('bet-stat').textContent = this.totalBet;
            document.getElementById('credits-stat').textContent = this.credits;

            const actionButton = document.getElementById('action-button');
            
            // Update Auto Hold Button Text and Color
            const autoHoldButton = document.getElementById('auto-hold-toggle');
            if (autoHoldButton) {
                 autoHoldButton.classList.remove('on', 'off');
                 autoHoldButton.classList.add(this.isAutoHoldOn ? 'on' : 'off');
                 autoHoldButton.textContent = 'AUTO HOLD OFF';
            }
            
            // Update Text Toggle Button Text and Color
            const textToggleButton = document.getElementById('text-toggle');
            if (textToggleButton) {
                textToggleButton.classList.remove('on', 'off');
                textToggleButton.classList.add(this.isTextHidden ? 'off' : 'on');
                textToggleButton.textContent = 'HIDE TEXT';
            }


            // --- Control Button States ---
            if (this.gameState === "END_ROUND" || this.gameState === "DEAL") {
                 actionButton.disabled = false;
                 actionButton.textContent = (this.gameState === "END_ROUND") ? "NEW HAND" : "DEAL";
            } else { // ACTION_PHASE
                 actionButton.disabled = !!this.activeManualJoker; 
                 actionButton.textContent = "DRAW";
            }
            
            // âš¡ï¸ Card Rendering: 3 Rows âš¡ï¸
            const handContainers = [
                document.querySelector('#hand-1 .hand-cards-container'), 
                document.querySelector('#hand-2 .hand-cards-container'), 
                document.getElementById('card-area') 
            ];

            handContainers.forEach(container => container.innerHTML = '');

            for (let i = 0; i < NUM_HANDS; i++) {
                const hand = this.playerHands[i];
                const container = handContainers[i];
                if (!hand || hand.length !== 5) continue;

                const isBaseHand = (i === 2);

                hand.forEach((card, index) => {
                    const slot = document.createElement('div');
                    slot.className = 'card-slot';

                    // 1. HOLD Indicator (×¨×§ ×œ×™×“ ×”×‘×¡×™×¡ - Hand 2)
                    if (isBaseHand) {
                         const holdIndicator = document.createElement('div');
                         holdIndicator.className = 'hold-indicator';
                         holdIndicator.textContent = 'HELD';
                         if (this.heldCards[index]) holdIndicator.classList.add('held');
                         slot.appendChild(holdIndicator);
                    }

                    // 2. Card Image/Text
                    const cardDiv = document.createElement('div');
                    cardDiv.id = isBaseHand ? `card-${index}` : `card-${i}-${index}`;
                    cardDiv.className = `card-image ${card ? card.getColorClass() : ''}`;
                    
                    // ×ª× ××™ ×¤×ª×™×—×ª ×§×œ×¤×™×:
                    let isVisible = isBaseHand || this.heldCards[index];
                    let isFaceDown = (this.gameState === "DEAL" || (!isVisible && this.gameState !== "END_ROUND"));

                    
                    if (isFaceDown || !card) {
                         cardDiv.classList.add('face-down');
                         cardDiv.textContent = '';
                    } else {
                        // ×§×œ×£ ×’×œ×•×™ (×”×¦×’×ª ×ª××•× ×”)
                        cardDiv.style.backgroundImage = `url('${card.getImagePath()}')`;
                        cardDiv.textContent = '';
                        cardDiv.classList.remove('face-down');
                    }
                    
                    // 3. ×”×¦×’×ª ×¨×™×‘×•×¢ ×–×›×™×™×” ××¢×œ ×”×§×œ×£ ×”×××¦×¢×™ (××™× ×“×§×¡ 2)
                    if (this.gameState === "END_ROUND" && index === 2) {
                         const handWin = this.winningHandNames.find(w => w.handIndex === i);
                         if (handWin) {
                             const winOverlay = document.createElement('div');
                             // ×™×¦×™×¨×ª ××—×œ×§×” ××‘×•×¡×¡×ª ×©× ×”×™×“ (×œ×“×•×’××”: win-JacksOrBetter)
                             const winClass = getWinClass(handWin.name);
                             winOverlay.className = `win-overlay ${winClass}`;
                             winOverlay.innerHTML = `
                                 <div>${handWin.name}</div>
                                 <div class="win-amount">${handWin.winnings}</div>
                             `;
                             slot.appendChild(winOverlay);
                         }
                    }

                    
                    // ×”×’×“×¨×ª Tap action (×¨×§ ×œ×™×“ ×”×‘×¡×™×¡ - Hand 2)
                    if (isBaseHand && this.gameState === "ACTION_PHASE") {
                        cardDiv.onclick = () => this.activateOneTapJoker(index);
                        cardDiv.style.cursor = 'pointer';

                        // ×”×•×¡×¤×ª ×–×•×”×¨ ×¨××–×™×/×‘×—×™×¨×” ×™×“× ×™×ª ×¨×§ ×œ×™×“ ×”×‘×¡×™×¡
                        let isGlowing = false;
                        if (!this.actionCardUsedThisRound && !this.activeManualJoker && this.isGlowActive && this.bestJokerAction.type) {
                            if (this.bestJokerAction.type === 'mirror_hand') {
                                if (card && card.rank >= 2 && card.rank <= 4) { isGlowing = true; }
                            } else if (this.bestJokerAction.index === index) { isGlowing = true; }
                        }
                        if (isGlowing) { cardDiv.classList.add('joker-glow'); }
                        
                        if (this.activeManualJoker) {
                            if (this.activeManualJoker === 'upgrade' || this.activeManualJoker === 'flush_fever') {
                                if (isCardValidForAction(card, this.playerHands[2], index, this.activeManualJoker) && !this.actionCardUsedThisRound) {
                                    cardDiv.classList.add('selected-for-action');
                                } else {
                                    cardDiv.classList.add('joker-not-selectable');
                                }
                            }
                        }
                    } else {
                        cardDiv.onclick = null;
                        cardDiv.style.cursor = 'default';
                    }

                    slot.appendChild(cardDiv);
                    container.appendChild(slot);
                });
            }


            // --- Joker Card Display (Text-based, Simplified, with custom colors) ---
            const actionContainer = document.getElementById('action-cards-container');
            actionContainer.innerHTML = '';
            
            // âš¡ï¸ ×”×¤×¢×œ×ª ×¢××¢×•× ×›×œ×œ×™ ×× ×™×© ×”×™× ×˜ ×¤×¢×™×œ ×•×˜×¨× × ×‘×—×¨ ×’'×•×§×¨ âš¡ï¸
            if (this.isGlowActive && !this.actionCardUsedThisRound && !this.activeManualJoker) {
                 actionContainer.classList.add('dim-non-active');
            } else {
                 actionContainer.classList.remove('dim-non-active');
            }


            const jokerUsedType = this.jokerUsedType;
            const activeManualJoker = this.activeManualJoker;
            const pendingJokerName = this.isGlowActive && this.bestJokerAction.type ? this.bestJokerAction.type : null;
            
            // ×”×’×“×¨×ª ×§×œ××¡×™× ×œ×¦×‘×¢×™× ×”×™×™×—×•×“×™×™×
            const jokerColorClasses = [
                'joker-color-1', // BOOSTER JOKER
                'joker-color-2', // FLUSH JOKER
                'joker-color-3'  // MIRROR JOKER
            ];

            ACTION_CARD_DEFINITIONS.forEach((ac, index) => {
                const slot = document.createElement('div');
                slot.className = 'action-card-slot';

                const button = document.createElement('button');
                button.className = 'action-card-button';
                button.disabled = this.actionCardUsedThisRound || this.gameState !== "ACTION_PHASE"; 
                
                if (activeManualJoker && ac.name === activeManualJoker) {
                     button.onclick = () => this.cancelManualJokerMode();
                } else {
                     button.onclick = () => this.setManualJokerMode(ac.name);
                }

                const cardImageDiv = document.createElement('div');
                cardImageDiv.className = `action-card-image ${jokerColorClasses[index]}`; 
                
                // âš¡ï¸ ×”×¦×’×ª ×©× ×”×’'×•×§×¨ ×‘××¨×›×– ×”×¨×™×‘×•×¢ âš¡ï¸
                cardImageDiv.textContent = ac.display.replace(" JOKER", ""); 
                
                let slotClass = '';
                // âš¡ï¸ ×©×™× ×•×™: ×”×•×¡×¤×ª ×ª× ××™ ×œ×‘×“×™×§×ª ×”×¨××– ×”×¦×”×•×‘ ×‘××¡×’×¨×ª âš¡ï¸
                if (jokerUsedType === ac.name) {
                    slotClass = 'used';
                } else if (!jokerUsedType && (activeManualJoker === ac.name || pendingJokerName === ac.name)) {
                    slotClass = 'pending'; // ××¦×‘ ××•×¦×¢/× ×‘×—×¨ ×™×“× ×™×ª - ××¤×¢×™×œ ××¡×’×¨×ª ×¦×”×•×‘×”
                }
                
                if (slotClass) slot.classList.add(slotClass);

                const cardTextDiv = document.createElement('div'); 
                
                button.appendChild(cardImageDiv);
                slot.appendChild(button);
                actionContainer.appendChild(slot);
            });
            
            document.getElementById('message-area').textContent = this.message;
            this.updateHandStatus(evaluateHand(this.playerHands[2]));
        }
    }

    // Initialize the game when the script loads
    const game = new PokerGame();

    // Attach events for new global controls
    document.addEventListener('DOMContentLoaded', () => {
        const soundToggle = document.getElementById('sound-toggle');
        const helpButton = document.getElementById('help-button');
        const autoHoldToggle = document.getElementById('auto-hold-toggle');
        const textToggle = document.getElementById('text-toggle');

        if (soundToggle) { soundToggle.onclick = toggleSound; }
        if (helpButton) { helpButton.onclick = openHelpFile; }
        if (autoHoldToggle) { autoHoldToggle.onclick = () => game.toggleAutoHold(); }
        if (textToggle) {
             textToggle.onclick = () => game.toggleTextDisplay();
             if (game.isTextHidden) {
                 textToggle.classList.add('off');
                 textToggle.textContent = 'SHOW TEXT';
             } else {
                 textToggle.classList.add('on');
                 textToggle.textContent = 'HIDE TEXT';
             }
        }
        
        // ××ª×—×•×œ ×”×ª×¦×•×’×”
        game.replicateHolds();
        game.updateUI();
    });

</script>
</body>
</html>